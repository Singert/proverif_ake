(*DONE:*)
(*TODO:*)
(*åŠ å…¥ B â†’ A çš„è®¤è¯ã€åŠ å…¥ç­¾åã€æˆ–æ¨¡æ‹Ÿæ¶æ„ä¸­é—´äººï¼Œæˆ‘å¯ä»¥ç»§ç»­å¸®åŠ©å»ºæ¨¡ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ*)
(*
ğŸ” åŒå‘è®¤è¯ï¼ˆA éªŒè¯ Bï¼‰
ğŸ”‘ éå¯¹ç§°å¯†é’¥æœºåˆ¶ï¼ˆRSA/ç­¾åï¼‰
ğŸ¤ Diffie-Hellman åè®®å»ºæ¨¡
*)
(* ç±»å‹å®šä¹‰ *)
type key.
type nonce.
type sessionkey.

(* ç±»å‹è½¬æ¢å™¨ï¼šç”¨äºå°† sessionkey å’Œ nonce è½¬æ¢ä¸º bitstring *)
fun toBits(sessionkey): bitstring [typeConverter].
fun nonceToBit(nonce): bitstring [typeConverter].
(* ç±»å‹è½¬æ¢å™¨ï¼šç”¨äºå°† bitstring è½¬æ¢ä¸º sessionkey *)
fun fromBits(bitstring): sessionkey [typeConverter].


(* æ„é€ å™¨ä¸è¿˜åŸè§„åˆ™ *)
fun pair(bitstring, bitstring): bitstring.
reduc forall x,y:bitstring; proj1(pair(x,y)) = x.
reduc forall x,y:bitstring; proj2(pair(x,y)) = y.

fun senc(bitstring, key): bitstring.
reduc forall k: key, m: bitstring; sdec(senc(m, k), k) = m.

(* å¸¸é‡ï¼šèº«ä»½æ ‡è¯†ç¬¦ *)
const A_ID : bitstring.
const B_ID : bitstring.

(* é€šé“ä¸å…±äº«å¯†é’¥ *)
free c : channel.
free k : key [private].

(* äº‹ä»¶å£°æ˜ï¼šéƒ½ç”¨ bitstring è¡¨ç¤ºæŒ‘æˆ˜ *)
event beginA(bitstring, sessionkey).
event endB(bitstring, sessionkey).

(* æŸ¥è¯¢ï¼šæœºå¯†æ€§ + A çš„è®¤è¯æ€§ *)
query attacker(new sk).
query nb: bitstring, sk: sessionkey; event(endB(nb, sk)) ==> event(beginA(nb, sk)).



(* A çš„è¿›ç¨‹ï¼šå“åº”æŒ‘æˆ˜ã€å‘é€ä¼šè¯å¯†é’¥ *)
let A =
  in(c, nb: bitstring);                        (* æ¥æ”¶ B çš„æŒ‘æˆ˜ï¼ˆbitstring ç±»å‹ï¼‰ *)
  new sk: sessionkey;
  event beginA(nb, sk);
  let payload = pair(nb, toBits(sk)) in        (* è½¬æ¢ sk ä¸º bitstring å† pair *)
  out(c, senc(payload, k)).

(* B çš„è¿›ç¨‹ï¼šå‘å‡ºæŒ‘æˆ˜ã€éªŒè¯ A çš„å“åº” *)
let B =
  out(c, A_ID);
  new nb: nonce;
  out(c, nonceToBit(nb));                      (* å‘é€ nonceï¼Œç»è½¬æ¢åä½œä¸º bitstring *)
  in(c, reply: bitstring);
  let payload = sdec(reply, k) in
  let rcv_nb = proj1(payload) in
  let sk = proj2(payload) in
  if rcv_nb = nonceToBit(nb) then
    event endB(rcv_nb, fromBits(sk))
  else
    0.

(* ä¸»è¿›ç¨‹ *)
process
  (!A | !B)

