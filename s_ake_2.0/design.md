我们将进入路线 🧪：**验证协议的扩展安全属性**，包括：

---

## ✅ 本轮将验证以下三项核心扩展安全性目标：

| 属性名                                          | 含义                                               | 威胁模型                 |
| -------------------------------------------- | ------------------------------------------------ | -------------------- |
| **KCI 抗性**<br>(Key Compromise Impersonation) | 即使攻击者掌握 A 的私钥，也**不能伪造 B 与 A 协商的会话密钥 `sk`**       | 攻击者得到了 `skA`，尝试伪装成 B |
| **前向保密性（PFS）**                               | 即使长期密钥（如 `skA`, `skB`）泄露，攻击者**不能恢复过去的会话密钥 `sk`** | 攻击者后来得到了私钥，回溯历史通信    |
| **Key Confirmation**                         | A 和 B **都知道并接受相同的 `sk`**                         | 确保无状态混乱、无中间人干扰       |

---

## 🔧 当前协议情况分析（是否已满足）

| 属性        | 当前状态      | 说明                             |
| --------- | --------- | ------------------------------ |
| KCI 抗性    | ❌ **待验证** | 当前攻击者若掌握 `skA`，可能重放或伪造         |
| PFS       | ❌ **不满足** | `sk` 是 A 单方面生成的，长期私钥泄露 ⇒ sk 泄露 |
| Key Conf. | ✅ **已具备** | 使用注释事件和匹配 `sk` 可验证一致性          |

---

## 🔍 本轮目标

我们将：

1. **验证是否具备 KCI 抗性**；
2. **说明为何当前协议不具备 PFS**；
3. **添加查询验证 Key Confirmation（`sk` 一致性）是否成立**。

---

### ✅ 验证 1：KCI 抗性

在 ProVerif 中模拟攻击者获取 `skA`：

```proverif
(* 模拟攻击者知道 A 的签名私钥 *)
free skA: skey.
```

让我们重新声明：

```proverif
free skA: skey.           (* 之前是 private，这里变成攻击者已知 *)
```

然后我们添加如下查询：

```proverif
(* 攻击者掌握 skA 的前提下，是否能伪造 endB 成功？ *)
query na: bitstring, nb: bitstring, sk: sessionkey;
      event(endB(na, nb, sk)) ==> event(beginA(na, nb, sk)).
```

如果仍然返回 `true`，说明协议 **具备 KCI 抗性**。

---

### ✅ 验证 2：前向保密（PFS）

要具备 PFS，必须：

* 会话密钥 `sk` 来自 `g^{ab}`，即临时 DH；
* 而你当前 `sk` 是 A 直接生成的（`new sk`），并通过加密发送；
* 如果攻击者事后得到 `skA`, `skB`, `skB_enc`，他可以：

  * 解密 A → B 消息，恢复 `sk`；
  * 或模拟 A 发起新的 sk；

所以**PFS 不成立**。

---

### ✅ 验证 3：Key Confirmation

添加如下查询：

```proverif
(* 若 A 接受 sk，那么 B 一定也曾接受相同 sk *)
query na: bitstring, nb: bitstring, sk: sessionkey;
      event(endA(na, sk)) ==> event(endB(na, nb, sk)).
```

如果 `true`，则说明双方达成共识的 `sk` 是一致的，具备 Key Confirmation。

---

## ✅ 总结

| 验证项              | 查询形式                              | 判断方式              |
| ---------------- | --------------------------------- | ----------------- |
| KCI 抗性           | 攻击者已知 `skA` 时验证 `endB ==> beginA` | 若仍为 `true` ⇒ 抗性成立 |
| PFS（前向保密）        | 无需验证，当前不满足                        | 必须用 DH 改进实现       |
| Key Confirmation | `endA(sk) ==> endB(sk)`           | 若为 `true` ⇒ sk 一致 |

---

是否现在帮你**实际修改模型以模拟 `skA` 泄露验证 KCI 抗性**？还是立即改造为 PFS（引入 Diffie-Hellman）？你可指定：`验证 KCI` 或 `引入 PFS`。
